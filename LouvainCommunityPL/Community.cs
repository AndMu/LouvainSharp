using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Threading.Tasks;
using System.Diagnostics;

namespace LouvainCommunityPL {
    /// <summary>
    /// This class implements community detection.
    /// 
    /// Adapted from python-louvain, http://perso.crans.org/aynaud/communities/, by Kyle Miller (v-kymil@microsoft.com) February 2014
    /// 
    /// Original copyright:
    ///   Copyright (C) 2009 by
    ///   Thomas Aynaud <thomas.aynaud@lip6.fr>
    ///   All rights reserved.
    ///   BSD license.
    /// </summary>
    public static class Community {

        internal static int PASS_MAX = -1;
        internal static double MIN = 0.0000001;
        
        /// <summary>
        /// Compute the modularity of a partition of a graph.
        /// 
        /// Raises:
        /// KeyNotFoundException if the partition does not partition all graph nodes
        /// InvalidOperationException if the graph has no link
        /// 
        /// References:
        /// 1. Newman, M.E.J. & Girvan, M. Finding and evaluating community structure in networks. Physical Review E 69, 26113(2004).
        /// </summary>
        /// <param name="graph">The graph which is decomposed.</param>
        /// <param name="partition">The partition of the nodes in the graph (i.e., a dictionary where keys are nodes and values are communities).</param>
        /// <returns>The modularity.</returns>
        public static double Modularity(Graph graph, Dictionary<int, int> partition) {
            Dictionary<int, double> inc = new Dictionary<int, double>();
            Dictionary<int, double> deg = new Dictionary<int, double>();

            double links = graph.Size;
            if (links == 0) {
                throw new InvalidOperationException("A graph without links has undefined modularity.");
            }

            foreach (int node in graph.Nodes) {
                int com = partition[node];
                deg[com] = DictGet(deg, com, 0) + graph.Degree(node);
                foreach (var edge in graph.IncidentEdges(node)) {
                    int neighbor = edge.ToNode;
                    if (partition[neighbor] == com) {
                        double weight;
                        if (neighbor == node) {
                            weight = edge.Weight;
                        } else {
                            weight = edge.Weight/2;
                        }
                        inc[com] = DictGet(inc, com, 0) + weight;
                    }
                }
            }

            double res = 0;
            foreach (int component in partition.Values.Distinct()) {
                res += DictGet(inc, component, 0) / links - Math.Pow(DictGet(deg, component, 0) / (2 * links), 2);
            }
            return res;
        }

        /// <summary>
        /// Compute the partition of the graph nodes which maximises the modularity using the Louvain heuristics (or try...)
        /// 
        /// This is the partition of the highest modularity, i.e., the highest partition of the dendrogram generated by the Louvain algorithm.
        /// 
        /// See also: GenerateDendrogram to obtain all the decomposition levels
        /// 
        /// Notes: Uses the Louvain algorithm
        /// 
        /// References:
        /// 1. Blondel, V.D. et al. Fast unfolding of communities in large networks. J. Stat. Mech 10008, 1-12(2008).
        /// </summary>
        /// <param name="graph">The graph which is decomposed.</param>
        /// <param name="partition">The algorithm will start using this partition of nodes. It is a dictionary where keys are nodes and values are communities.</param>
        /// <returns>The partition, with communities number from 0 onward, sequentially</returns>
        public static Dictionary<int, int> BestPartition(Graph graph, Dictionary<int, int> partition) {
            Dendrogram dendro = GenerateDendrogram(graph, partition);
            return dendro.PartitionAtLevel(dendro.Length - 1);
        }

        /// <summary>
        /// Does BestPartition without an initial partition.
        /// </summary>
        /// <param name="graph">The graph for which to find the best partition.</param>
        /// <returns>The best partition of the graph.</returns>
        public static Dictionary<int, int> BestPartition(Graph graph) {
            return BestPartition(graph, null);
        }

        public static Dendrogram GenerateDendrogram(Graph graph, Dictionary<int, int> part_init) {
            Dictionary<int, int> partition;
            Stopwatch stopwatch = new Stopwatch();
            stopwatch.Restart();

            // Special case, when there is no link, the best partition is everyone in its own community.
            if (graph.NumberOfEdges == 0) {
                partition = new Dictionary<int, int>();
                int i = 0;
                foreach (int node in graph.Nodes) {
                    partition[node] = i++;
                }
                return new Dendrogram(partition);
            }
            
            Graph current_graph = new Graph(graph);
            Status status = new Status(current_graph, part_init);
            double mod = status.Modularity();
            List<Dictionary<int, int>> status_list = new List<Dictionary<int, int>>();
            status.OneLevel(current_graph);
            double new_mod;
            new_mod = status.Modularity();

            int iterations = 1;
            do {
                iterations++;
                partition = Renumber(status.Node2Com);
                status_list.Add(partition);
                mod = new_mod;
                current_graph = current_graph.Quotient(partition);
                status = new Status(current_graph, null);
                status.OneLevel(current_graph);
                new_mod = status.Modularity();
            } while (new_mod - mod >= MIN);
            //Console.Out.WriteLine("(GenerateDendrogram: {0} iterations in {1})", iterations, stopwatch.Elapsed);

            return new Dendrogram(status_list);
        }

        private static Dictionary<A, int> Renumber<A>(Dictionary<A, int> dict) {
            var ret = new Dictionary<A, int>();
            var new_values = new Dictionary<int, int>();

            foreach (A key in dict.Keys.OrderBy(a => a)) {
                int value = dict[key];
                int new_value;
                if (!new_values.TryGetValue(value, out new_value)) {
                    new_value = new_values[value] = new_values.Count;
                }
                ret[key] = new_value;
            }
            return ret;
        }

        private static B DictGet<A, B>(Dictionary<A, B> dict, A key, B defaultValue) {
            B result;
            if (dict.TryGetValue(key, out result)) {
                return result;
            } else {
                return defaultValue;
            }
        }

       
    }


   
}
